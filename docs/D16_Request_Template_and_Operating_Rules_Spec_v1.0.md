D16. Requestテンプレート＆運用ルール（Request Template & Operating Rules Spec）v1.0

対象：ローカルDevin風 開発代理システム（aiflow-local）
前提：D3（Requestファイル）／D6（UI）／D10（Runner）／D4（Step Plan）／D15（TS）
制約：SSOTは requests/*.md、長い実装はStep反復、回帰はE2Eで担保、総合テストは人間が実施

1. 目的

Request（要望）を 最小労力で、失敗しにくい形 に標準化する

Runnerが planning 時に必要な情報（制約・AC・回帰・テスト指示）を 毎回揃えられる ようにする

優先度運用・WIP制限・差し戻しの書き方を固定し、運用を安定させる

2. 基本運用ルール（最重要）
2.1 1 Request = 1 目的（1機能/1修正）

1 Request が複数目的を含む場合、原則分割する

「UI＋API＋DB」跨ぎは許容するが、目的は単一に保つ

2.2 WIP制限（同時進行の上限）

running は 同時に1件（v1標準）

それ以上は queued に積む（優先度で処理順を決める）

2.3 受け入れ条件（AC）は最低3つ

うち1つは可能なら 回帰担保（E2E） を含める

ACは Given/When/Then 形式を推奨（曖昧さが減る）

2.4 回帰担保の原則

「既存フローが壊れない」は 必ずE2E（D4/D10）

E2Eが書けない場合は、例外として 人間の総合テスト手順 を明示する

2.5 総合テスト（人間）が最後のゲート

Runnerのdoneは「PR準備完了」に近い

最終の要件マッチは人間がブラウザで確認し、必要なら差し戻す

3. 優先度運用
3.1 優先度の定義（v1）

P0：作業を止める致命障害／セキュリティ重大

P1：主要機能の不具合／直近リリースに必要

P2：改善（UX/性能）／開発効率改善

P3：アイデア／将来対応

3.2 優先順位の決め方（ルール）

原則：P0 > P1 > P2 > P3

同一優先度では：

影響範囲が小さい（早く終わる）

回帰リスクが低い

ユーザー価値が高い
の順で前倒し

3.3 Request内での指定

front-matter風に書く（パースしやすい）

例：

md
priority: P1
type: bugfix
area: auth

4. Requestテンプレート（標準）

ファイル名（D14）：RQ-YYYYMMDD-NNN-<slug>.md
内容テンプレート（コピペ用）：

md
---
id: RQ-YYYYMMDD-NNN-<slug>
priority: P2
type: feature|bugfix|refactor|chore|doc
area: ui|api|db|infra|test|docs
base: main
---

# <短いタイトル>

## Want（要望）
- なにをどうしたいか（1〜3行）
- ユーザー視点の期待結果を1文で

## 背景 / Why（任意）
- なぜ必要か（優先度の根拠があればここ）

## 前提/制約（固定）
- PHP/Laravel
- DB: MySQL
- 既存仕様は壊さない
- ghコマンド依存なし、git依存OK
- トークン不要PRモード

## 影響範囲（わかる範囲で）
- 画面:
- API:
- DB:
- 既存フロー:

## 受け入れ条件（最低3つ）
- [ ] (AC1) Given: ... When: ... Then: ...
- [ ] (AC2) Given: ... When: ... Then: ...
- [ ] (AC3/回帰) 既存フローYが回帰しない（E2Eで担保）

## テスト指示（あれば）
### E2E
- シナリオ: ログイン → 放置 → 操作 → 期待結果
- データ条件（必要なら）

### 単体（Unit）
- サービス層の〜〜をテスト
- 境界条件（null/空/異常値）

## 非機能（必要なら）
- 性能:
- セキュリティ:
- 可観測性: ログ/エラー表示

## Plan（Runnerが埋める）
<!-- aiflow:plan -->

## Report（Runnerが埋める）
<!-- aiflow:report -->

5. タイプ別のテンプレ補助（書き分けルール）
5.1 bugfix

Wantには「現象」と「期待」を分けて書く

ACには「再現条件」と「修正後の確認」を必ず入れる

可能なら「再現E2E（落ちる）→修正後PASS」を作る

5.2 feature

ACに「表示」「保存」「エラー系」を最低1つずつ入れる

既存画面変更があるなら回帰AC（E2E）は必須

5.3 refactor

Wantに「外部仕様は一切変えない」を明記

ACは「差分なし」「テスト増」「E2E維持」など“安全”に寄せる

6. 差し戻し（needs_input/再指示）の書き方

Runnerが needs_input になったとき、ユーザーは Request に追記して再実行する。

6.1 追記ルール

## Report の末尾に追記ブロックを追加する（履歴を残す）

例：

md
## Report
...

### Human Follow-up (2025-12-14)
- 判断：A案で進めて
- 制約追加：既存の画面Xの文言は変えない
- AC追加：条件Cのときエラーメッセージは「〜」を表示

6.2 再実行の原則

追記後に Re-run

既存コミットを活かす（大きな巻き戻しは基本しない）

7. “長くなりすぎる問題” の運用ルール（必須）
7.1 Stepを小さく刻む前提を明文化

「1 Step = 1コミット」

「Stepは300行/10ファイルを超えたら分割（目安）」（D11/D10）

7.2 先に“足場Step”を作る

Planの最初のStepは原則これ：

既存コードの確認

必要なテストの追加（落ちるテスト→直す）

最小の変更で通すルートを作る

8. 回帰AC（E2E）の書き方ガイド（例）

悪い例：

「既存が壊れない」

良い例：

「E2E: ログイン → ダッシュボード → タスク追加 → 一覧に反映（既存フローY）」

「E2E: 期限指定 → 繰り返し → 保存 → 再読込後も保持」

9. リリース前の“人間総合テスト” チェックリスト（運用）

最低限、done後にあなたが確認する項目（テンプレ化推奨）：

ACをすべて手元で再確認（画面/挙動）

主要フローYを一通り操作（回帰）

権限・入力バリデーションを軽く触る（想定外入力）

例外系のUI表示（エラー文言、遷移）

Compare URLのdiffをざっと眺める（危険変更がないか）

10. 受け入れ基準（本Spec）

Requestをこのテンプレで書けば、RunnerがPlan→Step反復→Reportまで回せる

ACが3つ以上あり、回帰AC（E2E）が標準化される

needs_input の追記方法が固定され、再実行がスムーズ

優先度運用とWIP制限により、キューが破綻しない

“長すぎて途中停止” をStep分割ルールで吸収できる

ここまでで「仕様ドキュメント一式（D1〜D16）」が揃った状態です。次は実装フェーズに入るなら、最小PoCとして (1) aiflow dev 起動、(2) Request作成、(3) planningだけ生成、(4) Step1だけ実装 の順で作るのが最短ルートです。

